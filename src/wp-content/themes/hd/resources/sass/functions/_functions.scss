@use "sass:list";
@use "sass:math";
@use "sass:color";
@use "sass:string";
@use "sass:meta";
@use "sass:map";

// Ascending
// Used to evaluate Sass maps like our grid breakpoints.
@mixin _assert-ascending($map, $map-name) {
    $prev-key: null;
    $prev-num: null;
    @each $key, $num in $map {
        @if $prev-num == null or math.unit($num) == "%" or math.unit($prev-num) == "%" {
            // Do nothing
        } @else if not math.compatible($prev-num, $num) {
            @warn "Potentially invalid value for #{$map-name}: This map must be in ascending order, but key '#{$key}' has value #{$num} whose unit makes it incomparable to #{$prev-num}, the value of the previous key '#{$prev-key}' !";
        } @else if $prev-num >= $num {
            @warn "Invalid value for #{$map-name}: This map must be in ascending order, but key '#{$key}' has value #{$num} which isn't greater than #{$prev-num}, the value of the previous key '#{$prev-key}' !";
        }
        $prev-key: $key;
        $prev-num: $num;
    }
}

// Starts at zero
// Used to ensure the min-width of the lowest breakpoint starts at 0.
@mixin _assert-starts-at-zero($map, $map-name: "$grid-breakpoints") {
    @if length($map) > 0 {
        $values: map.values($map);
        $first-value: list.nth($values, 1);
        @if $first-value != 0 {
            @warn "First breakpoint in #{$map-name} must start at 0, but starts at #{$first-value}.";
        }
    }
}

// Replace `$search` with `$replace` in `$string`
// Used on our SVG icon backgrounds for custom forms.
//
// @author Kitty Giraudel
// @param {String} $string - Initial string
// @param {String} $search - Substring to replace
// @param {String} $replace ('') - New value
// @return {String} - Updated string
@function str-replace($string, $search, $replace: "") {
    $index: string.index($string, $search);

    @if $index {
        @return string.slice($string, 1, $index - 1) + $replace + str-replace(string.slice($string, $index + string.length($search)), $search, $replace);
    }

    @return $string;
}

// url-encode
@function url-encode($string) {
    $map: (
            "%": "%25",
            "<": "%3C",
            ">": "%3E",
            " ": "%20",
            "!": "%21",
            "*": "%2A",
            "'": "%27",
            '"': "%22",
            "(": "%28",
            ")": "%29",
            ";": "%3B",
            ":": "%3A",
            "@": "%40",
            "&": "%26",
            "=": "%3D",
            "+": "%2B",
            "$": "%24",
            ",": "%2C",
            "/": "%2F",
            "?": "%3F",
            "#": "%23",
            "[": "%5B",
            "]": "%5D"
    );
    $new: $string;
    @each $search, $replace in $map {
        $new: str-replace($new, $search, $replace);
    }
    @return $new;
}

/** $string - svg */
@function inline-svg($string) {
    @return url('data:image/svg+xml;utf8,#{url-encode($string)}');
}

/** add unique id image url */
@function inline-image($url) {
    $version: string.unique_id();
    @return url("#{$url}?v=#{$version}");
}

/** https://webdesign.tutsplus.com/tutorials/an-introduction-to-error-handling-in-sass--cms-19996 */
@function throw($log: '') {
    @warn $log;
    @return false;
}

/** get breakpoint */
@function get-breakpoint($breakpoint, $mq-breakpoints, $fallback: null) {
    @if map.has-key($mq-breakpoints, $breakpoint) {
        @return map.get($mq-breakpoints, $breakpoint);
    } @else if $fallback != null {
        @warn "Fallback used: `#{$fallback}` for `#{$breakpoint}` not found in `#{$mq-breakpoints}`";
        @return $fallback;
    } @else {
        @error "Given `#{$breakpoint}` is not available in `#{$mq-breakpoints}` and no fallback provided.";
    }
}

// Colors
@function to-rgb($value) {
    @return color.red($value), color.green($value), color.blue($value);
}

// A list of pre-calculated numbers of pow(divide((divide($value, 255) + .055), 1.055), 2.4). (from 0 to 255)
// stylelint-disable-next-line scss/dollar-variable-default, scss/dollar-variable-pattern
$_luminance-list: .0008 .001 .0011 .0013 .0015 .0017 .002 .0022 .0025 .0027 .003 .0033 .0037 .004 .0044 .0048 .0052 .0056 .006 .0065 .007 .0075 .008 .0086 .0091 .0097 .0103 .011 .0116 .0123 .013 .0137 .0144 .0152 .016 .0168 .0176 .0185 .0194 .0203 .0212 .0222 .0232 .0242 .0252 .0262 .0273 .0284 .0296 .0307 .0319 .0331 .0343 .0356 .0369 .0382 .0395 .0409 .0423 .0437 .0452 .0467 .0482 .0497 .0513 .0529 .0545 .0561 .0578 .0595 .0612 .063 .0648 .0666 .0685 .0704 .0723 .0742 .0762 .0782 .0802 .0823 .0844 .0865 .0887 .0908 .0931 .0953 .0976 .0999 .1022 .1046 .107 .1095 .1119 .1144 .117 .1195 .1221 .1248 .1274 .1301 .1329 .1356 .1384 .1413 .1441 .147 .15 .1529 .1559 .159 .162 .1651 .1683 .1714 .1746 .1779 .1812 .1845 .1878 .1912 .1946 .1981 .2016 .2051 .2086 .2122 .2159 .2195 .2232 .227 .2307 .2346 .2384 .2423 .2462 .2502 .2542 .2582 .2623 .2664 .2705 .2747 .2789 .2831 .2874 .2918 .2961 .3005 .305 .3095 .314 .3185 .3231 .3278 .3325 .3372 .3419 .3467 .3515 .3564 .3613 .3663 .3712 .3763 .3813 .3864 .3916 .3968 .402 .4072 .4125 .4179 .4233 .4287 .4342 .4397 .4452 .4508 .4564 .4621 .4678 .4735 .4793 .4851 .491 .4969 .5029 .5089 .5149 .521 .5271 .5333 .5395 .5457 .552 .5583 .5647 .5711 .5776 .5841 .5906 .5972 .6038 .6105 .6172 .624 .6308 .6376 .6445 .6514 .6584 .6654 .6724 .6795 .6867 .6939 .7011 .7084 .7157 .7231 .7305 .7379 .7454 .7529 .7605 .7682 .7758 .7835 .7913 .7991 .807 .8148 .8228 .8308 .8388 .8469 .855 .8632 .8714 .8796 .8879 .8963 .9047 .9131 .9216 .9301 .9387 .9473 .956 .9647 .9734 .9823 .9911 1;

@function color-contrast($background, $color-contrast-dark: #000000, $color-contrast-light: #ffffff, $min-contrast-ratio: 4.5) {
    $foregrounds: $color-contrast-light, $color-contrast-dark, #ffffff, #000000;
    $max-ratio: 0;
    $max-ratio-color: null;

    @each $color in $foregrounds {
        $contrast-ratio: contrast-ratio($background, $color);
        @if $contrast-ratio > $min-contrast-ratio {
            @return $color;
        } @else if $contrast-ratio > $max-ratio {
            $max-ratio: $contrast-ratio;
            $max-ratio-color: $color;
        }
    }

    @warn "Found no color leading to #{$min-contrast-ratio}:1 contrast ratio against #{$background}...";

    @return $max-ratio-color;
}

@function contrast-ratio($background, $foreground: #ffffff) {
    $l1: luminance($background);
    $l2: luminance(opaque($background, $foreground));

    @return if($l1 > $l2, divide($l1 + .05, $l2 + .05), divide($l2 + .05, $l1 + .05));
}

// Return WCAG2.1 relative luminance
// See https://www.w3.org/TR/WCAG/#dfn-relative-luminance
// See https://www.w3.org/TR/WCAG/#dfn-contrast-ratio
@function luminance($color) {
    $rgb: (
            "r": color.red($color),
            "g": color.green($color),
            "b": color.blue($color)
    );

    @each $name, $value in $rgb {
        $value: if(divide($value, 255) < .04045, divide(divide($value, 255), 12.92), list.nth($_luminance-list, $value + 1));
        $rgb: map.merge($rgb, ($name: $value));
    }

    @return (map.get($rgb, "r") * .2126) + (map.get($rgb, "g") * .7152) + (map.get($rgb, "b") * .0722);
}

// Return opaque color
// opaque(#fff, rgba(0, 0, 0, .5)) => #808080
@function opaque($background, $foreground) {
    @return color.mix(rgba($foreground, 1), $background, opacity($foreground) * 100%);
}

// Tint a color: mix a color with white
@function tint-color($color, $weight) {
    @return color.mix(white, $color, $weight);
}

// Shade a color: mix a color with black
@function shade-color($color, $weight) {
    @return color.mix(black, $color, $weight);
}

// Shade the color if the weight is positive, else tint it
@function shift-color($color, $weight) {
    @return if($weight > 0, shade-color($color, $weight), tint-color($color, -$weight));
}

/// Divide the given `$divident` by the given `$divisor`.
///
/// @param {Number} $divident - The divident.
/// @param {Number} $divisor - The divisor.
/// @param {Number} $precision - The precision decimals for the division.
///
/// @return {Number} The product of the division.
@function divide($dividend, $divisor, $precision: 12) {
    $sign: if($dividend > 0 and $divisor > 0 or $dividend < 0 and $divisor < 0, 1, -1);
    $dividend: math.abs($dividend);
    $divisor: math.abs($divisor);
    @if $dividend == 0 {
        @return 0;
    }
    @if $divisor == 0 {
        @error 'Cannot divide by 0';
    }
    $remainder: $dividend;
    $result: 0;
    $factor: 10;
    @while ($remainder > 0 and $precision >= 0) {
        $quotient: 0;
        @while ($remainder >= $divisor) {
            $remainder: $remainder - $divisor;
            $quotient: $quotient + 1;
        }
        $result: $result * 10 + $quotient;
        $factor: $factor * 0.1;
        $remainder: $remainder * 10;
        $precision: $precision - 1;
        @if ($precision < 0 and $remainder >= $divisor * 5) {
            $result: $result + 1;
        }
    }
    $result: $result * $factor * $sign;
    $dividend-unit: math.unit($dividend);
    $divisor-unit: math.unit($divisor);
    $unit-map: (
            'px': 1px,
            'rem': 1rem,
            'em': 1em,
            '%': 1%
    );
    @if ($dividend-unit != $divisor-unit and map.has-key($unit-map, $dividend-unit)) {
        $result: $result * map.get($unit-map, $dividend-unit);
    }

    @return $result;
}

/// Return valid calc
@function add($value1, $value2, $return-calc: true) {
    @if $value1 == null {
        @return $value2;
    }

    @if $value2 == null {
        @return $value1;
    }

    @if meta.type-of($value1) == number and meta.type-of($value2) == number and math.compatible($value1, $value2) {
        @return $value1 + $value2;
    }

    @return if($return-calc == true, calc(#{$value1} + #{$value2}), $value1 + string.unquote(" + ") + $value2);
}

/// The primary purpose of these functions is to avoid errors when a “unitless” 0 value is passed into a calc expression.
// Expressions like calc(10px - 0) will return an error in all browsers, despite being mathematically correct.
@function subtract($value1, $value2, $return-calc: true) {
    @if $value1 == null and $value2 == null {
        @return null;
    }

    @if $value1 == null {
        @return -$value2;
    }

    @if $value2 == null {
        @return $value1;
    }

    @if meta.type-of($value1) == number and meta.type-of($value2) == number and math.compatible($value1, $value2) {
        @return $value1 - $value2;
    }

    @if meta.type-of($value2) != number {
        $value2: string.unquote("(") + $value2 + string.unquote(")");
    }

    @return if($return-calc == true, calc(#{$value1} - #{$value2}), $value1 + string.unquote(" - ") + $value2);
}

/// Removes the unit (e.g. px, em, rem) from a value, returning the number only.
///
/// @param {Number} $num - Number to strip unit from.
///
/// @returns {Number} The same number, sans unit.
@function strip-unit($num) {
    @return divide($num, $num * 0 + 1);
}

/// Converts one or more pixel values into matching rem values.
///
/// @param {Number|List} $values - One or more values to convert. Be sure to separate them with spaces and not commas. If you need to convert a comma-separated list, wrap the list in parentheses.
/// @param {Number} $base [null] - The base value to use when calculating the `rem`. If you're using Foundation out of the box, this is 16px. If this parameter is `null`, the function will reference the `$global-font-size` variable as the base.
///
/// @returns {List} A list of converted values.
@function rem-calc($values, $base: null) {
    $rem-values: ();
    $count: list.length($values);

    // If no base is defined, defer to the global font size
    @if $base == null {
        $base: 100%;
    }

    // If the base font size is a %, then multiply it by 16px
    // This is because 100% font size = 16px in most all browsers
    @if math.unit($base) == '%' {
        $base: divide($base, 100%) * 16px;
    }

    // Using rem as base allows correct scaling
    @if math.unit($base) == 'rem' {
        $base: strip-unit($base) * 16px;
    }

    @if $count == 1 {
        @return -zf-to-rem($values, $base);
    }

    @for $i from 1 through $count {
        $rem-values: list.append($rem-values, -zf-to-rem(list.nth($values, $i), $base));
    }

    @return $rem-values;
}

/** size */
@function fs($size: 16) {
    @if false == $size {
        @warn '`#{$size}` is not a valid size!';
        @return null;
    } @else if auto == $size or inherit == $size or initial == $size or unset == $size or math.unit($size) == '%' {
        @return $size;
    } @else {
        @return rem-calc($size);
    }
}

$unit-warnings: true !default;

/// Converts a pixel value to matching rem value. *Any* value passed, regardless of unit, is assumed to be a pixel value. By default, the base pixel value used to calculate the rem value is taken from the `$global-font-size` variable.
/// @access private
///
/// @param {Number} $value - Pixel value to convert.
/// @param {Number} $base [null] - Base for pixel conversion.
///
/// @returns {Number} A number in rems, calculated based on the given value and the base pixel value. rem values are passed through as is.
@function -zf-to-rem($value, $base: null) {
    // Check if the value is a number
    @if meta.type-of($value) != 'number' {
        @if $unit-warnings {
            @warn inspect($value) + ' was passed to rem-calc(), which is not a number.';
        }
        @return $value;
    }

    // Transform em into rem if someone hands over 'em's
    @if math.unit($value) == 'em' {
        $value: strip-unit($value) * 1rem;
    }

    // Calculate rem if units for $value is not rem or em
    @if math.unit($value) != 'rem' {
        $value: divide(strip-unit($value), strip-unit($base)) * 1rem;
    }

    // Turn 0rem into 0
    @if $value == 0rem {
        $value: 0;
    }

    @return $value;
}
